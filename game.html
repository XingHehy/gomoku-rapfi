<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>五子棋人机对战</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Microsoft Yahei", sans-serif;
    }
    body {
      background-color: #f5f2e9;
      padding: 30px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    .control-panel {
      width: 520px;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row label {
      color: #8b4513;
      font-weight: 600;
      font-size: 14px;
    }
    select, input[type="number"] {
      padding: 6px 10px;
      border: 2px solid #c8b99c;
      border-radius: 6px;
      background: #fff;
      font-size: 14px;
      outline: none;
    }
    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      padding: 8px 18px;
      border: none;
      border-radius: 4px;
      background-color: #8b4513;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button:disabled {
      background-color: #c9b28f;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #a0522d;
    }
    #showStepBtn.active {
      background-color: #d2691e;
    }
    .status {
      font-size: 15px;
      color: #6f3b15;
      font-weight: 600;
      line-height: 1.3;
      min-height: 20px;
      word-break: break-all;
    }
    .step-info {
      font-size: 18px;
      color: #8b4513;
      font-weight: 700;
    }
    .chess-container {
      position: relative;
      /* 保持棋盘区域为正方形，优先使用固定宽度，窄屏时撑满屏宽 */
      width: min(520px, 100vw);
      aspect-ratio: 1 / 1;
    }
    .chess-row-num {
      position: absolute;
      left: 0;
      top: 20px;
      width: 20px;
      height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      text-align: center;
      font-size: 14px;
      color: #8b4513;
      font-weight: 700;
      line-height: 1;
      user-select: none;
    }
    .chess-col-num {
      position: absolute;
      left: 20px;
      top: 0;
      width: calc(100% - 20px);
      height: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-align: center;
      font-size: 14px;
      color: #8b4513;
      font-weight: 700;
      user-select: none;
    }
    .chess-board {
      width: calc(100% - 20px);
      height: calc(100% - 20px);
      background-color: #e6d4b9;
      border: 8px solid #8b4513;
      border-radius: 4px;
      position: absolute;
      left: 20px;
      top: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      overflow: hidden;
      touch-action: manipulation;
    }
    .chess-grid {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    .grid-row {
      width: 100%;
      height: 1px;
      background-color: #000;
      position: absolute;
      left: 0;
      opacity: 0.9;
    }
    .grid-col {
      height: 100%;
      width: 1px;
      background-color: #000;
      position: absolute;
      top: 0;
      opacity: 0.9;
    }
    .chess-dot {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #000;
      transform: translate(-50%, -50%);
      z-index: 5;
      pointer-events: none;
    }
    .chess-piece {
      width: calc(100% / 15 - 4px);
      height: calc(100% / 15 - 4px);
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      z-index: 10;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: 700;
      font-size: 12px;
      user-select: none;
    }
    .black {
      background-color: #000;
      border: 1px solid #666;
      color: #fff;
    }
    .white {
      background-color: #fff;
      border: 1px solid #eee;
      color: #000;
    }
    .last-move {
      outline: 3px solid #ff6b00;
      outline-offset: -2px;
    }
    .hint {
      font-size: 13px;
      color: #8b4513;
      opacity: 0.9;
    }
    @media (max-width: 768px) {
      .control-panel { width: 100%; }
      .chess-container { width: 100%; }
      button { padding: 6px 14px; font-size: 14px; }
      .step-info { font-size: 16px; }
      .chess-row-num, .chess-col-num { font-size: 12px; }
      .chess-dot { width: 6px; height: 6px; }
      .chess-piece {
        width: calc(100% / 15 - 6px);
        height: calc(100% / 15 - 6px);
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="control-panel">
    <div class="row">
      <label for="humanUid">我的uid</label>
      <input id="humanUid" type="number" value="1000" />
    </div>

    <div class="btn-group">
      <button id="newGameBtn">新开一局</button>
      <button id="autoBtn">自动：开</button>
      <button id="aiHelpBtn">AI帮我走一步</button>
      <button id="showStepBtn">显示手数</button>
    </div>

    <div class="status" id="status"></div>
    <div class="step-info" id="stepInfo">当前步数：0</div>
    <div class="hint">提示：点击棋盘落子（坐标 0-14）。AI 会在轮到它时自动应手（或关闭自动后手动点“AI走一步”）。</div>
  </div>

  <div class="chess-container">
    <div class="chess-row-num" id="chessRowNum"></div>
    <div class="chess-col-num" id="chessColNum"></div>
    <div class="chess-board" id="board">
      <div class="chess-grid" id="chessGrid"></div>
      <div id="chessDots"></div>
      <div id="chessPieces"></div>
    </div>
  </div>

  <script>
    const chessSize = 15;
    const dotPoints = [
      {r:3, c:3}, {r:3, c:7}, {r:3, c:11},
      {r:7, c:3}, {r:7, c:7}, {r:7, c:11},
      {r:11, c:3}, {r:11, c:7}, {r:11, c:11}
    ];

    const humanUidEl = document.getElementById('humanUid');
    const newGameBtn = document.getElementById('newGameBtn');
    const showStepBtn = document.getElementById('showStepBtn');
    const statusEl = document.getElementById('status');
    const stepInfo = document.getElementById('stepInfo');
    const chessGrid = document.getElementById('chessGrid');
    const chessRowNum = document.getElementById('chessRowNum');
    const chessColNum = document.getElementById('chessColNum');
    const chessDots = document.getElementById('chessDots');
    const chessPieces = document.getElementById('chessPieces');
    const boardEl = document.getElementById('board');

    let moves = []; // [{uid,r,c}]
    let isShowStep = false;
    let busy = false;
    let gameOver = false;
    let lastMoveIndex = -1;
    const AI_UID = 0;
    let userIsBlack = true; // 开局随机：用户是黑还是白
    let autoMode = true; // 默认自动：开（你执白后手时会自动请求 AI 下第一步）

    function setStatus(msg) {
      statusEl.textContent = msg || '';
    }

    function getHumanUid() {
      return Number(humanUidEl.value || 1000);
    }

    const aiHelpBtn = document.getElementById('aiHelpBtn');
    const autoBtn = document.getElementById('autoBtn');

    function getBlackUid() {
      return userIsBlack ? getHumanUid() : AI_UID;
    }

    function getWhiteUid() {
      return userIsBlack ? AI_UID : getHumanUid();
    }

    function expectedUid() {
      // 规则：list 第一个 uid 为黑，之后轮流
      if (moves.length === 0) return getBlackUid();
      return (moves.length % 2 === 0) ? getBlackUid() : getWhiteUid();
    }

    function isCellOccupied(r, c) {
      return moves.some(m => m.r === r && m.c === c);
    }

    function currentPlayerUid() {
      // 这里只用于页面提示：按“第一个 uid 为黑方”规则推断轮到谁
      return expectedUid();
    }

    function initChessBoard() {
      chessGrid.innerHTML = '';
      const gridGap = 100 / (chessSize - 1);
      for (let i = 0; i < chessSize - 1; i++) {
        const row = document.createElement('div');
        row.className = 'grid-row';
        row.style.top = `${i * gridGap}%`;
        chessGrid.appendChild(row);
        const col = document.createElement('div');
        col.className = 'grid-col';
        col.style.left = `${i * gridGap}%`;
        chessGrid.appendChild(col);
      }
      chessRowNum.innerHTML = '';
      for (let i = 0; i < chessSize; i++) {
        const num = document.createElement('div');
        num.textContent = i;
        chessRowNum.appendChild(num);
      }
      chessColNum.innerHTML = '';
      for (let i = 0; i < chessSize; i++) {
        const num = document.createElement('div');
        num.textContent = i;
        chessColNum.appendChild(num);
      }
      chessDots.innerHTML = '';
      dotPoints.forEach(point => {
        const dot = document.createElement('div');
        dot.className = 'chess-dot';
        dot.style.left = (point.c * gridGap) + '%';
        dot.style.top = (point.r * gridGap) + '%';
        chessDots.appendChild(dot);
      });
    }

    function updateStepInfo() {
      stepInfo.textContent = `当前步数：${moves.length}`;
    }

    function renderPieces() {
      chessPieces.innerHTML = '';
      const gridGap = 100 / (chessSize - 1);
      moves.forEach((m, idx) => {
        const piece = document.createElement('div');
        const isBlack = (idx % 2 === 0); // 第1手(索引0)为黑
        piece.className = `chess-piece ${isBlack ? 'black' : 'white'} ${idx === lastMoveIndex ? 'last-move' : ''}`;
        piece.style.left = (m.c * gridGap) + '%';
        piece.style.top = (m.r * gridGap) + '%';
        piece.textContent = isShowStep ? String(idx + 1) : '';
        piece.title = `第${idx + 1}手 | ${isBlack ? '黑' : '白'} | uid:${m.uid} | (r:${m.r}, c:${m.c})`;
        chessPieces.appendChild(piece);
      });
      updateStepInfo();
      aiHelpBtn.disabled = busy || gameOver || autoMode;
      autoBtn.disabled = busy;
    }

    function inBounds(r, c) {
      return r >= 0 && r < chessSize && c >= 0 && c < chessSize;
    }

    function checkWinAt(lastR, lastC) {
      // 只检查最近一步是否成五
      const idx = moves.findIndex(m => m.r === lastR && m.c === lastC);
      if (idx < 0) return false;
      const uid = moves[idx].uid;
      const dirs = [
        [1, 0], [0, 1], [1, 1], [1, -1]
      ];
      for (const [dr, dc] of dirs) {
        let count = 1;
        for (let k = 1; k <= 4; k++) {
          const r = lastR + dr * k, c = lastC + dc * k;
          if (!inBounds(r, c)) break;
          if (moves.some(m => m.uid === uid && m.r === r && m.c === c)) count++;
          else break;
        }
        for (let k = 1; k <= 4; k++) {
          const r = lastR - dr * k, c = lastC - dc * k;
          if (!inBounds(r, c)) break;
          if (moves.some(m => m.uid === uid && m.r === r && m.c === c)) count++;
          else break;
        }
        if (count >= 5) return true;
      }
      return false;
    }

    function clickToCoord(ev) {
      const rect = boardEl.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const gap = rect.width / (chessSize - 1);
      const c = Math.round(x / gap);
      const r = Math.round(y / gap);
      return { r, c };
    }

    async function callEngineMoveForAI() {
      // 请求 AI（uid=0）走一步
      const userid = AI_UID;
      if (expectedUid() !== userid) {
        setStatus('还没有轮到 AI');
        return;
      }
      busy = true;
      setStatus('AI 计算中…');
      renderPieces();
      try {
        const resp = await fetch('/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ board: moves, userid })
        });
        const json = await resp.json();
        if (!json || json.success !== true) {
          setStatus(json?.message || 'AI 返回异常');
          return;
        }
        const r = Number(json.data.r);
        const c = Number(json.data.c);
        if (!inBounds(r, c)) {
          setStatus(`AI 返回坐标越界：r=${r}, c=${c}`);
          return;
        }
        if (isCellOccupied(r, c)) {
          setStatus(`AI 返回位置已被占用：r=${r}, c=${c}`);
          return;
        }
        moves.push({ uid: AI_UID, r, c });
        lastMoveIndex = moves.length - 1;
        renderPieces();

        if (checkWinAt(r, c)) {
          gameOver = true;
          setStatus('AI 获胜（五连）');
          return;
        }
        setStatus('轮到你落子');
      } catch (e) {
        setStatus('请求失败：' + e.message);
      } finally {
        busy = false;
        renderPieces();
      }
    }

    function maybeAutoPlay() {
      if (!autoMode) return;
      if (busy || gameOver) return;
      if (expectedUid() !== AI_UID) return;
      callEngineMoveForAI().then(() => {});
    }

    function maybeStartEngineFirst() {
      if (getBlackUid() === getHumanUid()) {
        setStatus('本局随机：你执黑先手。');
      } else {
        setStatus('本局随机：你执白后手。');
      }
      maybeAutoPlay();
    }

    function resetGame() {
      moves = [];
      busy = false;
      gameOver = false;
      lastMoveIndex = -1;
      userIsBlack = Math.random() < 0.5;
      renderPieces();
      maybeStartEngineFirst();
    }

    function toggleShowStep() {
      isShowStep = !isShowStep;
      showStepBtn.classList.toggle('active', isShowStep);
      showStepBtn.textContent = isShowStep ? '隐藏手数' : '显示手数';
      renderPieces();
    }

    boardEl.addEventListener('click', async (ev) => {
      if (busy) return;
      if (gameOver) return;

      // 点击棋盘=用户落子
      const humanUid = getHumanUid();
      if (expectedUid() !== humanUid) {
        setStatus('还没有轮到您');
        return;
      }
      const { r, c } = clickToCoord(ev);
      if (!inBounds(r, c)) return;
      if (isCellOccupied(r, c)) {
        setStatus('该位置已落子');
        return;
      }

      moves.push({ uid: humanUid, r, c });
      lastMoveIndex = moves.length - 1;
      renderPieces();

      if (checkWinAt(r, c)) {
        gameOver = true;
        setStatus('你获胜（五连）');
        return;
      }

      setStatus('已落子，等待 AI…');
      maybeAutoPlay();
    });

    newGameBtn.addEventListener('click', resetGame);
    showStepBtn.addEventListener('click', toggleShowStep);
    aiHelpBtn.addEventListener('click', () => {
      if (busy || gameOver) return;
      callEngineMoveForAI().then(() => {});
    });
    autoBtn.addEventListener('click', () => {
      if (busy) return;
      autoMode = !autoMode;
      autoBtn.textContent = autoMode ? '自动：开' : '自动：关';
      renderPieces();
      maybeAutoPlay();
    });

    window.onload = function() {
      initChessBoard();
      resetGame();
    };
  </script>
</body>
</html>


